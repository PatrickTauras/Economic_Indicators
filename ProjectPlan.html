<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>projectplan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ProjectPlan_files/libs/clipboard/clipboard.min.js"></script>
<script src="ProjectPlan_files/libs/quarto-html/quarto.js"></script>
<script src="ProjectPlan_files/libs/quarto-html/popper.min.js"></script>
<script src="ProjectPlan_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ProjectPlan_files/libs/quarto-html/anchor.min.js"></script>
<link href="ProjectPlan_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ProjectPlan_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ProjectPlan_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ProjectPlan_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ProjectPlan_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<p><strong>Overview</strong></p>
<p>Analyzing the impact of GDP and inflation on employment trends.</p>
<p><strong>Research Question:</strong></p>
<p>How do changes in GDP and inflation impact employment trends across different industries in the United States?</p>
<p><strong>Team:</strong></p>
<p>Patrick Tauras (Data Engineer) and Justin Kutsor (Data Analyst). Patrick will gather and clean the data and allow Justin to use the data sets to see if changes in GDP and inflation impact employment trends.</p>
<p><strong>Datasets:</strong></p>
<p>The Employment Data from the Bureau of Labor Statistics (BLS) includes a JSON structure that begins with a status field indicating the success of the request, labeled as “REQUEST_SUCCEEDED”. The results section identifies the data series with the ID “CES0000000001”, which corresponds to Total Nonfarm Employment in the U.S. Each data entry within this series provides information by year and period, such as “2023” and “M12” for December. Additionally, the “PeriodName” field offers a human-readable month name, such as “December”, and the “Value” field represents the employment count (e.g., “157304”), which is given in thousands. The BLS data is structured on a month-by-month basis, categorized by year, making it suitable for detailed employment data analysis.</p>
<p>The GDP Data from the Federal Reserve Economic Data (FRED) API features metadata fields like “realtime_start”, “realtime_end”, “observation_start”, “observation_end”, and “count”, which provide context about the time frame and structure of the dataset. Each observation in the dataset includes a “Date” field for the specific date of the GDP observation (e.g., “1946-01-01”) and a “Value” field that denotes the GDP value (e.g., “243.164”), typically representing GDP in billions of dollars, depending on FRED’s series specifications. Some entries contain a “value”: “.”, indicating missing data for certain periods. The GDP data is organized on a quarterly basis, which is typical for long-term GDP trends, with actual values beginning in 1947, aligning with the historical availability of U.S. GDP data.</p>
<p>The Inflation Data from the Federal Reserve Economic Data (FRED) API includes a JSON structure designed to provide insights into inflation trends over time. The dataset begins with metadata fields, such as “realtime_start”, “realtime_end”, “observation_start”, “observation_end”, and “count”, which define the time frame and structure of the data retrieved. Each observation within this dataset contains a “date” field that specifies the exact date of the inflation measurement (e.g., “1947-01-01”), along with a “value” field representing the Consumer Price Index (CPI) for that month (e.g., “123.45”). This CPI value is an index number, typically used to calculate inflation by tracking changes in the cost of a basket of goods over time. Some entries in the dataset may contain “value”: “.”, indicating missing data points. The inflation data is generally structured on a monthly basis, making it compatible with employment data for detailed analysis of inflation trends over time. This setup enables the examination of inflation’s impact in relation to GDP and employment trends in the U.S.</p>
<p><strong>Timeline:</strong></p>
<p>Our project timeline is designed to hit all the key requirements in manageable steps. In Weeks 1-2, we’ll set up roles, organize our GitHub repo, and finalize our main research question. We’ll grab data from the FRED and BLS APIs, making sure each dataset has distinct licenses and formats, and we’ll add integrity checks to keep things reproducible.</p>
<p>Moving to Weeks 3-4, we’ll focus on integrating the datasets with Python and document the process. Week 5 is for data profiling and cleanup, making sure everything’s ready for analysis. From Weeks 6-7, we’ll dive into analysis and visualizations to explore how GDP and inflation impact employment trends, packaging it all in a reproducible format.</p>
<p>In Weeks 8-9, we’ll build an automated workflow to run everything smoothly from start to finish. For the final touches in Weeks 10-11, we’ll wrap up documentation, cite all our sources, create metadata, and archive the project on Zenodo for a persistent identifier. Our GitHub repo will track progress and contributions, keeping us organized and on target.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>